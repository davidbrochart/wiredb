{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>WireDB is a distributed database based on CRDTs. In particular, it uses pycrdt, a Python library providing bindings for Yrs (pronounce \"wires\"), the Rust port of Yjs.</p> <p>WireDB aims at making it easy to connect peers together through a variety of transport layers (called \"wires\"). Storage is provided as just another connection, for instance to a file.</p>"},{"location":"api_reference/","title":"API reference","text":""},{"location":"api_reference/#wiredb.Room","title":"<code>Room</code>","text":"<p>               Bases: <code>AsyncContextManagerMixin</code></p>"},{"location":"api_reference/#wiredb.Room.doc","title":"<code>doc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Doc</code> <p>The room's shared document.</p>"},{"location":"api_reference/#wiredb.Room.id","title":"<code>id</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The room ID.</p>"},{"location":"api_reference/#wiredb.Room.task_group","title":"<code>task_group</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>TaskGroup</code> <p>The room's task group, that can be used to launch background tasks.</p>"},{"location":"api_reference/#wiredb.Room.__init__","title":"<code>__init__(id)</code>","text":"<p>Creates a new room in which clients with the same ID will be connected.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The room ID.</p> required"},{"location":"api_reference/#wiredb.Room.run","title":"<code>run(*, task_status=TASK_STATUS_IGNORED)</code>  <code>async</code>","text":"<p>The main background task which is responsible for forwarding every update from a client to all other clients in the room.</p> <p>Parameters:</p> Name Type Description Default <code>task_status</code> <code>TaskStatus[None]</code> <p>The task status that is set when the task has started.</p> <code>TASK_STATUS_IGNORED</code>"},{"location":"api_reference/#wiredb.Room.serve","title":"<code>serve(client, *, task_status=TASK_STATUS_IGNORED)</code>  <code>async</code>","text":"<p>The handler for a client which is responsible for the connection handshake and for applying the client updates to the room's shared document.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Channel</code> <p>The client making the connection.</p> required <code>task_status</code> <code>TaskStatus[None]</code> <p>The task status that is set when the task has started.</p> <code>TASK_STATUS_IGNORED</code>"},{"location":"api_reference/#wiredb.bind","title":"<code>bind(wire, room_factory=Room, **kwargs)</code>","text":"<p>Creates a server using a <code>wire</code>, and its specific arguments. The server must always be used with an async context manager, for instance: <pre><code>async with bind(\"websocket\", host=\"localhost\", port=8000) as server:\n    ...\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>wire</code> <code>str</code> <p>The wire used to accept connections.</p> required <code>room_factory</code> <code>Callable[[str], Room]</code> <p>An optional callable used to create a room.</p> <code>Room</code> <code>kwargs</code> <code>Any</code> <p>The arguments that are specific to the wire.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ServerWire</code> <p>The created server.</p>"},{"location":"api_reference/#wiredb.connect","title":"<code>connect(wire, *, id='', doc=None, **kwargs)</code>","text":"<p>Creates a client using a <code>wire</code>, and its specific arguments. The client must always be used with an async context manager, for instance: <pre><code>async with connect(\"websocket\", host=\"localhost\", port=8000) as client:\n    ...\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>wire</code> <code>str</code> <p>The wire used to connect.</p> required <code>id</code> <code>str</code> <p>The ID of the room to connect to in the server.</p> <code>''</code> <code>doc</code> <code>Doc | None</code> <p>An optional external shared document (or a new one will be created).</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>The arguments that are specific to the wire.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ClientWire</code> <p>The created client.</p>"},{"location":"install/","title":"Install","text":"<p>WireDB can be installed through PyPI or conda-forge.</p>"},{"location":"install/#with-pip","title":"With <code>pip</code>","text":"<pre><code>pip install wiredb  # no wire installed\npip install \"wiredb[websocket,file]\"  # with wires \"websocket\" and \"file\"\n</code></pre>"},{"location":"install/#with-micromamba","title":"With <code>micromamba</code>","text":"<p>We recommend using <code>micromamba</code> to manage <code>conda-forge</code> environments (see <code>micromamba</code>'s installation instructions). First create an environment, here called <code>my_env</code>, and activate it: <pre><code>micromamba create -n my_env\nmicromamba activate my_env\n</code></pre></p> <p>Then install <code>wiredb</code>.</p> <pre><code>micromamba install wiredb\nmicromamba install wire-websocket wire-file  # install wires \"websocket\" and \"file\"\n</code></pre>"},{"location":"install/#development-install","title":"Development install","text":"<p>You first need to clone the repository:</p> <pre><code>git clone https://github.com/davidbrochart/wiredb\ncd wiredb\n</code></pre> <p>We recommend using uv. First create a virtual environment and activate it.</p> <pre><code>uv venv\nsource .venv/bin/activate  # on linux\n</code></pre> <p>Then install <code>wiredb</code> in editable mode: <pre><code>uv pip install -e \".[websocket,file]\"\n</code></pre></p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#quickstart","title":"Quickstart","text":"<p>WireDB has the notions of servers and clients. A server accepts connections from clients. Clients pass an <code>id</code> which is used to identify a \"room\" in the server. All clients in a room are kept in sync.</p> <p>In WireDB, clients and servers can use a variety of \"wires\", or transport layers. For instance, here is how you would connect two clients together through a web server (using WebSockets):</p> <pre><code>from anyio import run, sleep\nfrom pycrdt import Text\nfrom wiredb import bind, connect\n\nasync def main():\n    async with bind(\"websocket\", host=\"localhost\", port=8000) as server:\n        async with (\n            connect(\"websocket\", host=\"localhost\", port=8000) as client0,\n            connect(\"websocket\", host=\"localhost\", port=8000) as client1,\n        ):\n            text0 = client0.doc.get(\"text\", Text)\n            text0 += \"Hello, World!\"\n            await sleep(0.1)  # allow some time for synchronization\n            text1 = client1.doc.get(\"text\", Text)\n            assert str(text1) == \"Hello, World!\"\n\nrun(main)\n</code></pre> <p>This example runs on the same machine and in the same process, but it would run just as well if the server and the clients were located on different machines on the Internet.</p> <p>If you wanted to add persistence, you could connect a client to a file:</p> <pre><code>async def main():\n    async with bind(\"websocket\", host=\"localhost\", port=8000) as server:\n        async with (\n            connect(\"websocket\", host=\"localhost\", port=8000) as client0,\n            connect(\"websocket\", host=\"localhost\", port=8000) as client1,\n            connect(\"file\", doc=client1.doc, path=\"/path/to/updates.y\"),\n        ):\n            ...\n</code></pre> <p>But usually data is stored in the server, where clients are connected inside a room. Here is how you could connect these rooms to their corresponding files:</p> <pre><code>from anyio import sleep_forever\nfrom wiredb import Room\n\nclass MyRoom(Room):\n    async def run(self, *args, **kwargs):\n        await self.task_group.start(self.connect_to_file)\n        await super().run(*args, **kwargs)\n\n    async def connect_to_file(self, *, task_status) -&gt; None:\n        async with connect(\"file\", doc=self.doc, path=f\"/path/to/directory/{self.id}_updates.y\"):\n            task_status.started()\n            await sleep_forever()\n\nasync def main():\n    async with bind(\"websocket\", room_factory=MyRoom, host=\"localhost\", port=8000) as server:\n        async with (\n            connect(\"websocket\", id=\"my_id\", host=\"localhost\", port=8000) as client0,\n            connect(\"websocket\", id=\"my_id\", host=\"localhost\", port=8000) as client1,\n        ):\n            ...\n</code></pre> <p>The <code>id</code> of a <code>Room</code>  is used to map to file paths. In the example above, the clients connect to the server using <code>id=\"my_id\"</code>, so the file name will be <code>my_id_updates.y</code>.</p>"}]}